<html>
    <head>
        <title>My first Three.js app</title>
        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100% }
        </style>
    </head>
    <body>
        <script src="//code.jquery.com/jquery-1.11.3.min.js"></script>
        <script src="//code.jquery.com/jquery-migrate-1.2.1.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r73/three.min.js"></script>
        <script src="TrackballControls.js"></script>
        <script src="OrbitControls.js"></script>

        <!-- Shaders -->
        <script type="x-shader/x-vertex" id="FIREvertexshader">

            #ifdef GL_ES
                precision highp float;
            #endif

            varying vec3 st;
            uniform float time; 

            //
            // Description : Array and textureless GLSL 2D/3D/4D simplex 
            //               noise functions.
            //      Author : Ian McEwan, Ashima Arts.
            //  Maintainer : ijm
            //     Lastmod : 20110822 (ijm)
            //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
            //               Distributed under the MIT License. See LICENSE file.
            //               https://github.com/ashima/webgl-noise
            // 

            vec3 mod289(vec3 x) {
            return x - floor(x * (1.0 / 289.0)) * 289.0;
            }

            vec4 mod289(vec4 x) {
            return x - floor(x * (1.0 / 289.0)) * 289.0;
            }

            vec4 permute(vec4 x) {
            return mod289(((x*34.0)+1.0)*x);
            }

            vec4 taylorInvSqrt(vec4 r)
            {
            return 1.79284291400159 - 0.85373472095314 * r;
            }

            float snoise(vec3 v)
            { 
            const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
            const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

            // First corner
            vec3 i  = floor(v + dot(v, C.yyy) );
            vec3 x0 =   v - i + dot(i, C.xxx) ;

            // Other corners
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );

            //   x0 = x0 - 0.0 + 0.0 * C.xxx;
            //   x1 = x0 - i1  + 1.0 * C.xxx;
            //   x2 = x0 - i2  + 2.0 * C.xxx;
            //   x3 = x0 - 1.0 + 3.0 * C.xxx;
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
            vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

            // Permutations
            i = mod289(i); 
            vec4 p = permute( permute( permute( 
            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
            + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

            // Gradients: 7x7 points over a square, mapped onto an octahedron.
            // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
            float n_ = 0.142857142857; // 1.0/7.0
            vec3  ns = n_ * D.wyz - D.xzx;

            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);

            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );

            //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
            //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));

            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);

            //Normalise gradients
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;

            // Mix final noise value
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                            dot(p2,x2), dot(p3,x3) ) );
            }

            void main(void) {

                float displacement = 0.0;
                float t = time;

                displacement += (1.0/2.0) * snoise(vec3(0.25    * position.x + t*0.2, 0.25 * position.y + t*0.2, 0.25 * position.z));
                displacement += (1.0/4.0) * snoise(vec3(0.5     * position.x + t*0.2, 0.5  * position.y + t*0.2, 0.5 * position.z));
                displacement += (1.0/8.0) * snoise(vec3(1.0     * position.x + t*0.2, 1.0  * position.y + t*0.2, 1.0 * position.z));
                displacement += (1.0/16.0) * snoise(vec3(2.0    * position.x + t*0.2, 2.0  * position.y + t*0.2, 2.0 * position.z));
                displacement += (1.0/32.0) * snoise(vec3(4.0    * position.x + t*0.2, 4.0  * position.y + t*0.2, 4.0 * position.z));

                // move the position along the normal and transform it
                vec3 newPosition = position + normal * displacement;


                newPosition.z = (newPosition.z > 0.4)?0.4:newPosition.z;
                newPosition.y = (newPosition.y < -3.0)?-3.0:newPosition.y;
                st = newPosition;
                gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );   
            }
        </script>

        <script type="x-shader/x-fragment" id="FIREfragmentshader">

            #ifdef GL_ES
                precision highp float;
            #endif

            varying vec3 st; // Texcoords
            uniform float time; 

            vec4 mod289(vec4 x) {
                return x - floor(x * (1.0 / 289.0)) * 289.0; 
            }

            float mod289(float x) {
                return x - floor(x * (1.0 / 289.0)) * 289.0; 
            }

            vec4 permute(vec4 x) {
                return mod289(((x*34.0)+1.0)*x); 
            }

            float permute(float x) {
                return mod289(((x*34.0)+1.0)*x);
            }

            vec4 taylorInvSqrt(vec4 r) {
                return 1.79284291400159 - 0.85373472095314 * r;
            }

            float taylorInvSqrt(float r) {
                return 1.79284291400159 - 0.85373472095314 * r;
            }

            vec4 grad4(float j, vec4 ip) {
            const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
            vec4 p,s;

            p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
            p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
            s = vec4(lessThan(p, vec4(0.0)));
            p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; 

            return p;
            }

            // (sqrt(5) - 1)/4 = F4, used once below
            #define F4 0.309016994374947451

            float snoise(vec4 v) {
                const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4
                0.276393202250021,  // 2 * G4
                0.414589803375032,  // 3 * G4
                -0.447213595499958); // -1 + 4 * G4

                // First corner
                vec4 i  = floor(v + dot(v, vec4(F4)) );
                vec4 x0 = v -   i + dot(i, C.xxxx);

                // Other corners

                // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)
                vec4 i0;
                vec3 isX = step( x0.yzw, x0.xxx );
                vec3 isYZ = step( x0.zww, x0.yyz );
                //  i0.x = dot( isX, vec3( 1.0 ) );
                i0.x = isX.x + isX.y + isX.z;
                i0.yzw = 1.0 - isX;
                //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );
                i0.y += isYZ.x + isYZ.y;
                i0.zw += 1.0 - isYZ.xy;
                i0.z += isYZ.z;
                i0.w += 1.0 - isYZ.z;

                // i0 now contains the unique values 0,1,2,3 in each channel
                vec4 i3 = clamp( i0, 0.0, 1.0 );
                vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );
                vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );

                //  x0 = x0 - 0.0 + 0.0 * C.xxxx
                //  x1 = x0 - i1  + 1.0 * C.xxxx
                //  x2 = x0 - i2  + 2.0 * C.xxxx
                //  x3 = x0 - i3  + 3.0 * C.xxxx
                //  x4 = x0 - 1.0 + 4.0 * C.xxxx
                vec4 x1 = x0 - i1 + C.xxxx;
                vec4 x2 = x0 - i2 + C.yyyy;
                vec4 x3 = x0 - i3 + C.zzzz;
                vec4 x4 = x0 + C.wwww;

                // Permutations
                i = mod289(i); 
                float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);
                vec4 j1 = permute( permute( permute( permute (
                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))
                + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))
                + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))
                + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));

                // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope
                // 7*7*6 = 294, which is close to the ring size 17*17 = 289.
                vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;

                vec4 p0 = grad4(j0,   ip);
                vec4 p1 = grad4(j1.x, ip);
                vec4 p2 = grad4(j1.y, ip);
                vec4 p3 = grad4(j1.z, ip);
                vec4 p4 = grad4(j1.w, ip);

                // Normalise gradients
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;
                p4 *= taylorInvSqrt(dot(p4,p4));

                // Mix contributions from the five corners
                vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
                vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);
                m0 = m0 * m0;
                m1 = m1 * m1;
                return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))
                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;
            }       

            vec3 toFireColor(float n) {
                float red = n;
                float green = n*2.0-1.0;
                float blue = n*3.0-2.0;

                return vec3(red,green,blue);
            }

            void main() {
                float t = time;
                float alpha = 0.5;
                vec3 color = vec3(0.0,0.0,0.0);

                float n = 0.0;
                n += (1.0/2.0)      * abs(snoise(vec4(4.0*st.x, 1.0*st.y-1.0*t, 1.0*st.z, t*0.5)));
                n += (1.0/4.0)      * abs(snoise(vec4(8.0*st.x, 2.0*st.y-2.0*t, 2.0*st.z, t*0.5)));
                n += (1.0/8.0)      * abs(snoise(vec4(16.0*st.x, 3.0*st.y-4.0*t, 4.0*st.z, t*0.5)));
                n += (1.0/16.0)     * abs(snoise(vec4(32.0*st.x,4.0*st.y-5.0*t, 8.0*st.z, t*0.5)));

                n *= (3.0 - st.y);

                color = toFireColor(n);
                alpha = (n < 0.1)?0.0:alpha;

                //gl_FragColor = vec4(n,n,n, 0.5);
                gl_FragColor = vec4(color, alpha);
            }
        </script>

        <script type="x-shader/x-vertex" id="smokeVertexshader">

            #ifdef GL_ES
                precision highp float;
            #endif

            varying vec3 st;
            uniform float time; 

            //
            // Description : Array and textureless GLSL 2D/3D/4D simplex 
            //               noise functions.
            //      Author : Ian McEwan, Ashima Arts.
            //  Maintainer : ijm
            //     Lastmod : 20110822 (ijm)
            //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
            //               Distributed under the MIT License. See LICENSE file.
            //               https://github.com/ashima/webgl-noise
            // 

            vec3 mod289(vec3 x) {
            return x - floor(x * (1.0 / 289.0)) * 289.0;
            }

            vec4 mod289(vec4 x) {
            return x - floor(x * (1.0 / 289.0)) * 289.0;
            }

            vec4 permute(vec4 x) {
            return mod289(((x*34.0)+1.0)*x);
            }

            vec4 taylorInvSqrt(vec4 r)
            {
            return 1.79284291400159 - 0.85373472095314 * r;
            }

            float snoise(vec3 v)
            { 
            const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
            const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

            // First corner
            vec3 i  = floor(v + dot(v, C.yyy) );
            vec3 x0 =   v - i + dot(i, C.xxx) ;

            // Other corners
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );

            //   x0 = x0 - 0.0 + 0.0 * C.xxx;
            //   x1 = x0 - i1  + 1.0 * C.xxx;
            //   x2 = x0 - i2  + 2.0 * C.xxx;
            //   x3 = x0 - 1.0 + 3.0 * C.xxx;
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
            vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

            // Permutations
            i = mod289(i); 
            vec4 p = permute( permute( permute( 
            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
            + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

            // Gradients: 7x7 points over a square, mapped onto an octahedron.
            // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
            float n_ = 0.142857142857; // 1.0/7.0
            vec3  ns = n_ * D.wyz - D.xzx;

            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);

            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );

            //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
            //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));

            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);

            //Normalise gradients
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;

            // Mix final noise value
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                            dot(p2,x2), dot(p3,x3) ) );
            }

            void main(void) {

                float displacement = 0.0;
                float t = time;

                displacement += (1.0/2.0) * snoise(vec3(1.0 * position.x - t*0.2, 1.0 * position.y - t*0.2, 1.0 * position.z));
                displacement += (1.0/4.0) * snoise(vec3(2.0 * position.x - t*0.2, 2.0 * position.y - t*0.2, 2.0 * position.z));
                displacement += (1.0/8.0) * snoise(vec3(4.0 * position.x - t*0.2, 4.0 * position.y - t*0.2, 4.0 * position.z));
                displacement += (1.0/16.0) * snoise(vec3(8.0 * position.x - t*0.2, 8.0 * position.y - t*0.2, 8.0 * position.z));
                displacement += (1.0/32.0) * snoise(vec3(16.0 * position.x - t*0.2, 16.0 * position.y - t*0.2, 16.0 * position.z));

                // move the position along the normal and transform it
                vec3 newPosition = position + normal * displacement;
                st = newPosition;
                gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );   
            }
        </script>

        <script type="x-shader/x-fragment" id="smokeFragmentshader">

            #ifdef GL_ES
                precision highp float;
            #endif

            varying vec3 st; // Texcoords
            uniform float time; 

            vec4 mod289(vec4 x) {
                return x - floor(x * (1.0 / 289.0)) * 289.0; 
            }

            float mod289(float x) {
                return x - floor(x * (1.0 / 289.0)) * 289.0; 
            }

            vec4 permute(vec4 x) {
                return mod289(((x*34.0)+1.0)*x); 
            }

            float permute(float x) {
                return mod289(((x*34.0)+1.0)*x);
            }

            vec4 taylorInvSqrt(vec4 r) {
                return 1.79284291400159 - 0.85373472095314 * r;
            }

            float taylorInvSqrt(float r) {
                return 1.79284291400159 - 0.85373472095314 * r;
            }

            vec4 grad4(float j, vec4 ip) {
            const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
            vec4 p,s;

            p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
            p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
            s = vec4(lessThan(p, vec4(0.0)));
            p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; 

            return p;
            }

            // (sqrt(5) - 1)/4 = F4, used once below
            #define F4 0.309016994374947451

            float snoise(vec4 v) {
                const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4
                0.276393202250021,  // 2 * G4
                0.414589803375032,  // 3 * G4
                -0.447213595499958); // -1 + 4 * G4

                // First corner
                vec4 i  = floor(v + dot(v, vec4(F4)) );
                vec4 x0 = v -   i + dot(i, C.xxxx);

                // Other corners

                // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)
                vec4 i0;
                vec3 isX = step( x0.yzw, x0.xxx );
                vec3 isYZ = step( x0.zww, x0.yyz );
                //  i0.x = dot( isX, vec3( 1.0 ) );
                i0.x = isX.x + isX.y + isX.z;
                i0.yzw = 1.0 - isX;
                //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );
                i0.y += isYZ.x + isYZ.y;
                i0.zw += 1.0 - isYZ.xy;
                i0.z += isYZ.z;
                i0.w += 1.0 - isYZ.z;

                // i0 now contains the unique values 0,1,2,3 in each channel
                vec4 i3 = clamp( i0, 0.0, 1.0 );
                vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );
                vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );

                //  x0 = x0 - 0.0 + 0.0 * C.xxxx
                //  x1 = x0 - i1  + 1.0 * C.xxxx
                //  x2 = x0 - i2  + 2.0 * C.xxxx
                //  x3 = x0 - i3  + 3.0 * C.xxxx
                //  x4 = x0 - 1.0 + 4.0 * C.xxxx
                vec4 x1 = x0 - i1 + C.xxxx;
                vec4 x2 = x0 - i2 + C.yyyy;
                vec4 x3 = x0 - i3 + C.zzzz;
                vec4 x4 = x0 + C.wwww;

                // Permutations
                i = mod289(i); 
                float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);
                vec4 j1 = permute( permute( permute( permute (
                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))
                + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))
                + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))
                + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));

                // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope
                // 7*7*6 = 294, which is close to the ring size 17*17 = 289.
                vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;

                vec4 p0 = grad4(j0,   ip);
                vec4 p1 = grad4(j1.x, ip);
                vec4 p2 = grad4(j1.y, ip);
                vec4 p3 = grad4(j1.z, ip);
                vec4 p4 = grad4(j1.w, ip);

                // Normalise gradients
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;
                p4 *= taylorInvSqrt(dot(p4,p4));

                // Mix contributions from the five corners
                vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
                vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);
                m0 = m0 * m0;
                m1 = m1 * m1;
                return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))
                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;
            }       

            void main() {
                float t = time;
                float alpha = 0.3;
                vec3 color = vec3(0.0,0.0,0.0);

                float n = 0.0;
                n += (1.0/8.0)  * abs(snoise(vec4(2.0*st.x,     2.0*st.y-0.5*t,     2.0*st.z,   t*0.5)));

                n *= (1.0 - st.y);

                alpha = (n < 0.1)?0.0:alpha;

                //gl_FragColor = vec4(n,n,n, 0.5);
                gl_FragColor = vec4(n,n,n, alpha);
            }
        </script>

        <script>
            var scene, camera, renderer, fireball, plane, uniform, controls;
            var container;

            init();
            animate();

            function init() {

                container = document.createElement( 'div' );
                document.body.appendChild( container );

                /*
                 * Create the scene and set spec.
                 */
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000);
                camera.position.z = 20;

                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                container.appendChild( renderer.domElement );

                /*
                * Set config for the controls
                */
                controls = new THREE.OrbitControls( camera, renderer.domElement );
                controls.enableDamping = true;
                controls.dampingFactor = 0.25;
                controls.enableZoom = false;

                /*
                * Attributes to shaders
                */
                uniform = {
                    time: { type: "f", value: 1.0 }
                }

                /* 
                 *   Create a inner sphere
                 */
                var geometry = new THREE.SphereGeometry( 2.7, 500, 500 );
                // Set material for the inner sphere
                var shaderMaterial = new THREE.MeshPhongMaterial( { 
                    color: 0xdddddd, 
                    specular: 0x6b7a82, 
                    shininess: 100, 
                    //metal: true,
                    shading: THREE.FlatShading } )
                var innerBall = new THREE.Mesh(geometry, shaderMaterial);
                innerBall.position.x = 0;
                innerBall.position.y = -2;
                innerBall.position.z = 0;
                scene.add( innerBall );

                /* 
                 *   Create a burning sphere
                 */
                var geometry = new THREE.SphereGeometry( 3.0, 200, 20, 2.3, 5.3, 0 );
                //Set material for the burning
                var shaderMaterial =
                  new THREE.ShaderMaterial({
                    uniforms: uniform,
                    vertexShader:   document.getElementById('FIREvertexshader').innerHTML,
                    fragmentShader: document.getElementById('FIREfragmentshader').innerHTML,
                    transparent: true
                  });
                // Add shaders to the sphere
                fireball = new THREE.Mesh(geometry, shaderMaterial);
                fireball.position.x = 0;
                fireball.position.y = -1.5;
                fireball.position.z = 0;
                scene.add( fireball );

                /*
                *   Cylinders WITH SMOKE
                */
                // var smokeShader =
                //   new THREE.ShaderMaterial({
                //     uniforms: uniform,
                //     vertexShader:   document.getElementById('smokeVertexshader').innerHTML,
                //     fragmentShader: document.getElementById('smokeFragmentshader').innerHTML,
                //     transparent: true,
                //     depthWrite: false
                //   });

                // var geometry1 = new THREE.CylinderGeometry( 0, 3, 14, 32 );
                // var cylinder1 = new THREE.Mesh( geometry1, smokeShader );
                // cylinder1.position.y=5;
                // scene.add( cylinder1 );

                // var geometry2 = new THREE.CylinderGeometry( 0, 2.75, 14, 32 );
                // var cylinder2 = new THREE.Mesh( geometry2, smokeShader );
                // cylinder2.position.y=5.5;
                // scene.add( cylinder2 );

                // var geometry3 = new THREE.CylinderGeometry( 0, 2.5, 14, 32 );
                // var cylinder3 = new THREE.Mesh( geometry3, smokeShader );
                // cylinder3.position.y=6;
                // scene.add( cylinder3 );



                /*
                *   LIGHTS
                */

                var light = new THREE.AmbientLight( 0x404040 ); // soft white light
                scene.add( light )

                pointLight = new THREE.PointLight( 0x6b7a82, 0.5, 100 );
                pointLight.position.set( 20, 20, 30 );
                scene.add( pointLight );

            };

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            function animate() {
                requestAnimationFrame( animate );
                controls.update(); // required if controls.enableDamping = true, or if controls.autoRotate = true
                render();
            }

            function render() {
                uniform.time.value += 0.03;
                renderer.render( scene, camera );
            }

        </script>
    </body>
</html>